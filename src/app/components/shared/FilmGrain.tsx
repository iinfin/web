'use client';

import React, { useEffect, useRef } from 'react';

import { logger } from '@/lib/utils/logger';

import { useFilmGrain } from '@/hooks/useFilmGrain';

/**
 * Props for the FilmGrain component.
 */
interface FilmGrainProps {
	/** Optional override for the grain intensity (0-1). Defaults to context value. */
	intensity?: number;
	/** Optional override for the grain scale. Defaults to context value. */
	scale?: number;
	/** Optional override for the grain animation speed. Defaults to context value. */
	speed?: number;
	/** Optional additional CSS classes for the canvas element. */
	className?: string;
}

/**
 * Renders a full-screen, animated film grain effect using raw WebGL.
 *
 * This component creates a canvas overlay covering the viewport and draws
 * procedural noise generated by a GLSL shader. It reads configuration
 * from `FilmGrainContext` but allows overriding intensity, scale, and speed via props.
 * Returns `null` if the effect is disabled in the context.
 *
 * @param {FilmGrainProps} props - Component props.
 * @returns {JSX.Element | null} The canvas element or null.
 */
export default function FilmGrain({ intensity: intensityProp, scale: scaleProp, speed: speedProp, className = '' }: FilmGrainProps): JSX.Element | null {
	// Get settings from context
	const { enabled, intensity: contextIntensity, scale: contextScale, speed: contextSpeed } = useFilmGrain();

	// Use prop values if provided, otherwise use context values
	const intensity = intensityProp ?? contextIntensity;
	const scale = scaleProp ?? contextScale;
	const speed = speedProp ?? contextSpeed;

	// Component refs
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const requestRef = useRef<number>(0);
	const shaderProgramRef = useRef<WebGLProgram | null>(null);
	const timeRef = useRef<number>(0);

	// WebGL setup and animation effect
	useEffect(() => {
		// Skip effect entirely if the grain is disabled via context
		if (!enabled) return;

		// --- Canvas and WebGL Setup ---
		const canvas = canvasRef.current;
		if (!canvas) {
			logger.error('FilmGrain: Canvas element not found.');
			return;
		}

		// Get WebGL context with performance options
		const gl = canvas.getContext('webgl', {
			antialias: false,
			alpha: true,
			premultipliedAlpha: false,
			depth: false,
			stencil: false,
			preserveDrawingBuffer: false,
		});

		if (!gl) {
			logger.error('FilmGrain: WebGL context not available.');
			return;
		}

		// --- Canvas Size Handler ---
		const updateCanvasSize = () => {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			gl.viewport(0, 0, canvas.width, canvas.height);
		};

		updateCanvasSize();
		window.addEventListener('resize', updateCanvasSize);

		// --- Shader Sources ---
		// Vertex shader for positioning
		const vertexShaderSource = `
			attribute vec2 a_position;
			attribute vec2 a_texCoord;
			varying vec2 v_texCoord;

			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`;

		// Fragment shader for grain generation
		const fragmentShaderSource = `
			precision mediump float;
			varying vec2 v_texCoord;

			uniform float u_time;
			uniform float u_intensity;
			uniform float u_scale;
			uniform float u_speed;
			uniform vec2 u_resolution;

			// Fast hash function - no trig or complex math
			float hash(vec2 p) {
				p = fract(p * vec2(123.34, 456.21));
				p += dot(p, p + 45.32);
				return fract(p.x * p.y);
			}

			float filmGrain(vec2 uv, float time) {
				// Apply scale to UVs
				vec2 uvScaled = uv * u_scale * (u_resolution.y * 0.05);
				float t = time * u_speed;

				// Multiple noise layers with slightly different frequencies and orientations
				float noise1 = hash(uvScaled + t);
				float noise2 = hash(uvScaled * 1.4 + t * 1.2);
				float noise3 = hash(uvScaled * 0.8 - t * 0.7);

				// Mix the layers for a more organic look
				float grainLayer = mix(noise1, noise2, 0.4);
				grainLayer = mix(grainLayer, noise3, 0.3);

				// Curve the distribution for a more film-like appearance
				return pow(grainLayer, 1.5);
			}

			void main() {
				// Generate film grain
				float grain = filmGrain(v_texCoord, u_time);

				// Remap from [0,1] to [-1,1] and scale by intensity
				float grainValue = (grain * 2.0 - 1.0) * u_intensity;

				// For stronger visual effect, use black and white for grain
				// This creates more visible grain than a gray midpoint
				vec3 grainColor = vec3(step(0.5, grain + 0.5 * (grainValue * 0.1)));

				// Higher alpha for more visibility - adjust based on intensity
				float alpha = min(0.2 + u_intensity * 0.5, 0.9);

				gl_FragColor = vec4(grainColor, alpha);
			}
		`;

		// --- Shader Compilation ---
		const compileShader = (source: string, type: number): WebGLShader | null => {
			const shader = gl.createShader(type);
			if (!shader) {
				logger.error(`FilmGrain: Failed to create shader type ${type}`);
				return null;
			}
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				logger.error(`FilmGrain: Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`, gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return null;
			}
			return shader;
		};

		const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
		const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

		if (!vertexShader || !fragmentShader) return;

		// --- Program Setup ---
		const shaderProgram = gl.createProgram();
		if (!shaderProgram) {
			logger.error('FilmGrain: Failed to create shader program.');
			return;
		}
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);
		shaderProgramRef.current = shaderProgram;

		// Verify program linked successfully
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			logger.error('FilmGrain: Shader program failed to link:', gl.getProgramInfoLog(shaderProgram));
			gl.deleteProgram(shaderProgram);
			shaderProgramRef.current = null;
			return;
		}

		// Cleanup linked shaders
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);

		// --- Buffer Setup ---
		// Position buffer (for full-screen quad)
		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		// Texture coordinates buffer
		const texCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
		const texCoords = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

		// --- Get Shader Locations ---
		const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
		const texCoordAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_texCoord');
		const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
		const intensityUniformLocation = gl.getUniformLocation(shaderProgram, 'u_intensity');
		const scaleUniformLocation = gl.getUniformLocation(shaderProgram, 'u_scale');
		const speedUniformLocation = gl.getUniformLocation(shaderProgram, 'u_speed');
		const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');

		// --- WebGL State Configuration ---
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		// --- Animation Loop ---
		const animate = (time: number) => {
			timeRef.current = time * 0.001; // Convert to seconds

			// Use shader program
			gl.useProgram(shaderProgram);

			// Setup position attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.enableVertexAttribArray(positionAttributeLocation);
			gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

			// Setup texCoord attribute
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.enableVertexAttribArray(texCoordAttributeLocation);
			gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);

			// Update uniforms
			gl.uniform1f(timeUniformLocation, timeRef.current);
			gl.uniform1f(intensityUniformLocation, intensity);
			gl.uniform1f(scaleUniformLocation, scale);
			gl.uniform1f(speedUniformLocation, speed);
			gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

			// Draw the quad
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

			// Request next frame
			requestRef.current = requestAnimationFrame(animate);
		};

		// Start animation
		requestRef.current = requestAnimationFrame(animate);

		// --- Cleanup ---
		return () => {
			// Stop animation
			if (requestRef.current) {
				cancelAnimationFrame(requestRef.current);
			}

			// Remove resize handler
			window.removeEventListener('resize', updateCanvasSize);

			// Clean up WebGL resources
			if (gl && shaderProgramRef.current) {
				gl.deleteProgram(shaderProgramRef.current);
				shaderProgramRef.current = null;
			}
		};
	}, [intensity, scale, speed, enabled]);

	// Don't render if disabled
	if (!enabled) return null;

	// Render canvas with appropriate properties
	return <canvas ref={canvasRef} className={`pointer-events-none fixed inset-0 z-50 mix-blend-difference ${className}`} aria-hidden="true" />;
}
