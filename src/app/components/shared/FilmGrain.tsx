'use client';

import React, { useEffect, useRef } from 'react';

import { useFilmGrain } from '@/app/context/FilmGrainContext';
import { logger } from '@/app/utils/logger';

interface FilmGrainProps {
	/** Optional override for the grain intensity (0-1). Defaults to context value. */
	intensity?: number;
	/** Optional override for the grain scale. Defaults to context value. */
	scale?: number;
	/** Optional override for the grain animation speed. Defaults to context value. */
	speed?: number;
	/** Optional additional CSS classes for the canvas element. */
	className?: string;
}

/**
 * Renders a full-screen, animated film grain effect using raw WebGL.
 *
 * This component creates a canvas overlay covering the viewport and draws
 * procedural noise generated by a GLSL shader. It reads configuration
 * from `FilmGrainContext` but allows overriding intensity, scale, and speed via props.
 * Returns `null` if the effect is disabled in the context.
 *
 * @param {FilmGrainProps} props - Component props.
 * @returns {JSX.Element | null} The canvas element or null.
 */
export default function FilmGrain({ intensity: intensityProp, scale: scaleProp, speed: speedProp, className = '' }: FilmGrainProps): JSX.Element | null {
	const { enabled, intensity: contextIntensity, scale: contextScale, speed: contextSpeed } = useFilmGrain();

	// Use prop values if provided, otherwise use context values
	const intensity = intensityProp ?? contextIntensity;
	const scale = scaleProp ?? contextScale;
	const speed = speedProp ?? contextSpeed;

	const canvasRef = useRef<HTMLCanvasElement>(null);
	const requestRef = useRef<number>(0);
	const shaderProgramRef = useRef<WebGLProgram | null>(null);
	const timeRef = useRef<number>(0);

	// Effect for WebGL setup, animation loop, and cleanup
	useEffect(() => {
		// Skip effect entirely if the grain is disabled via context
		if (!enabled) return;

		const canvas = canvasRef.current;
		if (!canvas) {
			logger.error('FilmGrain: Canvas element not found.');
			return;
		}

		// --- 1. Get WebGL Context ---
		// Request a WebGL context with specific performance-oriented attributes.
		const gl = canvas.getContext('webgl', {
			antialias: false, // No anti-aliasing needed for this effect
			alpha: true, // Need alpha channel for blending
			premultipliedAlpha: false, // Shader outputs non-premultiplied alpha
			depth: false, // No depth buffer needed
			stencil: false, // No stencil buffer needed
			preserveDrawingBuffer: false, // Allows browser optimizations
		});

		if (!gl) {
			logger.error('FilmGrain: WebGL context not available.');
			return;
		}

		// --- 2. Canvas Size and Viewport --- (Handles Resize)
		const updateCanvasSize = () => {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			// Update the WebGL viewport to match the new canvas dimensions
			gl.viewport(0, 0, canvas.width, canvas.height);
		};

		updateCanvasSize(); // Set initial size
		window.addEventListener('resize', updateCanvasSize); // Update on resize

		// --- 3. Define Shaders --- (GLSL Source Code)
		// Vertex shader: Positions a full-screen quad and passes texture coordinates.
		const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

		// Fragment shader: Generates procedural film grain based on time and UVs.
		const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform float u_time;
      uniform float u_intensity;
      uniform float u_scale;
      uniform float u_speed;
      uniform vec2 u_resolution;

      // Fast hash function - no trig or complex math
      float hash(vec2 p) {
        p = fract(p * vec2(123.34, 456.21));
        p += dot(p, p + 45.32);
        return fract(p.x * p.y);
      }

      float filmGrain(vec2 uv, float time) {
        // Apply scale to UVs
        vec2 uvScaled = uv * u_scale * (u_resolution.y * 0.05);
        float t = time * u_speed;

        // Multiple noise layers with slightly different frequencies and orientations
        float noise1 = hash(uvScaled + t);
        float noise2 = hash(uvScaled * 1.4 + t * 1.2);
        float noise3 = hash(uvScaled * 0.8 - t * 0.7);

        // Mix the layers for a more organic look
        float grainLayer = mix(noise1, noise2, 0.4);
        grainLayer = mix(grainLayer, noise3, 0.3);

        // Curve the distribution for a more film-like appearance
        return pow(grainLayer, 1.5);
      }

      void main() {
        // Generate film grain
        float grain = filmGrain(v_texCoord, u_time);

        // Remap from [0,1] to [-1,1] and scale by intensity
        float grainValue = (grain * 2.0 - 1.0) * u_intensity;

        // For stronger visual effect, use black and white for grain
        // This creates more visible grain than a gray midpoint
        vec3 grainColor = vec3(step(0.5, grain + 0.5 * (grainValue * 0.1)));

        // Higher alpha for more visibility - adjust based on intensity
        float alpha = min(0.2 + u_intensity * 0.5, 0.9);

        gl_FragColor = vec4(grainColor, alpha);
      }
    `;

		// --- 4. Compile Shaders --- Helper function
		const compileShader = (source: string, type: number): WebGLShader | null => {
			const shader = gl.createShader(type);
			if (!shader) {
				logger.error(`FilmGrain: Failed to create shader type ${type}`);
				return null;
			}
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				logger.error(`FilmGrain: Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`, gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return null;
			}
			return shader;
		};

		const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
		const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

		if (!vertexShader || !fragmentShader) return; // Abort if compilation failed

		// --- 5. Create and Link Shader Program ---
		const shaderProgram = gl.createProgram();
		if (!shaderProgram) {
			logger.error('FilmGrain: Failed to create shader program.');
			return;
		}
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);
		shaderProgramRef.current = shaderProgram; // Store reference for cleanup

		// Check for linking errors
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			logger.error('FilmGrain: Shader program failed to link:', gl.getProgramInfoLog(shaderProgram));
			gl.deleteProgram(shaderProgram); // Clean up failed program
			shaderProgramRef.current = null;
			return;
		}

		// Shaders are linked, no longer needed individually
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);

		// --- 6. Setup Buffers for Fullscreen Quad ---
		// Buffer for vertex positions (-1 to 1 range)
		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]; // Triangle strip vertices
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		// Buffer for texture coordinates (0 to 1 range)
		const texCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
		const texCoords = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]; // Corresponding UVs
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

		// --- 7. Get Attribute and Uniform Locations ---
		// Locations for vertex attributes
		const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
		const texCoordAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_texCoord');
		// Locations for fragment shader uniforms
		const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
		const intensityUniformLocation = gl.getUniformLocation(shaderProgram, 'u_intensity');
		const scaleUniformLocation = gl.getUniformLocation(shaderProgram, 'u_scale');
		const speedUniformLocation = gl.getUniformLocation(shaderProgram, 'u_speed');
		const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');

		// --- 8. WebGL State Setup ---
		// Enable alpha blending for transparency
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Standard alpha blending

		// --- 9. Animation Loop ---
		const animate = (time: number) => {
			timeRef.current = time * 0.001; // Convert DOMHighResTimeStamp (ms) to seconds for shader

			// Use the compiled shader program
			gl.useProgram(shaderProgram);

			// Bind and configure vertex attributes
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.enableVertexAttribArray(positionAttributeLocation);
			gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.enableVertexAttribArray(texCoordAttributeLocation);
			gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);

			// Update shader uniforms with current values
			gl.uniform1f(timeUniformLocation, timeRef.current);
			gl.uniform1f(intensityUniformLocation, intensity); // Use context/prop value
			gl.uniform1f(scaleUniformLocation, scale); // Use context/prop value
			gl.uniform1f(speedUniformLocation, speed); // Use context/prop value
			gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

			// Draw the full-screen quad (triangle strip)
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

			// Request the next animation frame
			requestRef.current = requestAnimationFrame(animate);
		};

		// Start the animation loop
		requestRef.current = requestAnimationFrame(animate);

		// --- 10. Cleanup --- (Runs when component unmounts or dependencies change)
		return () => {
			// Stop the animation loop
			if (requestRef.current) {
				cancelAnimationFrame(requestRef.current);
			}
			// Remove the resize listener
			window.removeEventListener('resize', updateCanvasSize);

			// Clean up WebGL resources (buffers are implicitly cleaned, but program needs explicit deletion)
			if (gl && shaderProgramRef.current) {
				gl.deleteProgram(shaderProgramRef.current);
				shaderProgramRef.current = null; // Clear the ref
			}
		};
		// Rerun effect if configuration props change or if effect is enabled/disabled
	}, [intensity, scale, speed, enabled]);

	// If effect is disabled via context, render nothing.
	if (!enabled) return null;

	// Render the canvas element, positioned fixed to cover viewport.
	// pointer-events-none allows interactions with elements underneath.
	// mix-blend-difference creates the overlay effect.
	return <canvas ref={canvasRef} className={`pointer-events-none fixed inset-0 z-50 mix-blend-difference ${className}`} aria-hidden="true" />;
}
