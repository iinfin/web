---
description: Framer Motion Animation Best Practices Rule
globs: ["**/*.tsx"]
alwaysApply: true
---
## Description
Enforces best practices for implementing animations using Framer Motion and standard CSS transitions.

## Rule
1.  **Tool Choice**:
    *   Use standard CSS transitions/animations (`transition`, `animate-*` utilities in Tailwind) for simple, non-interactive state changes (e.g., hover effects, subtle background changes).
    *   Use Framer Motion (`motion` components, `animate` prop, variants, `useAnimate`, `staggerChildren`, `AnimatePresence`, etc.) for complex sequences, physics-based animations, layout animations, gesture-based interactions, and animating component mount/unmount.
2.  **Performance**:
    *   Prioritize animating `transform` (translate, scale, rotate) and `opacity` as they are typically hardware-accelerated. Avoid animating layout properties (width, height, margin, padding) frequently, as they trigger reflows/repaints.
    *   Use `will-change` CSS property sparingly via Tailwind (`will-change-transform`, `will-change-opacity`) if needed, but rely on Framer Motion's optimizations first.
    *   For list animations, use `staggerChildren` or `AnimatePresence` correctly to manage performance.
3.  **Framer Motion Components**: Wrap elements to be animated with `motion.` (e.g., `motion.div`, `motion.button`).
4.  **Animation Definition**:
    *   Use the `animate` prop for simple animations directly on `motion` components.
    *   Use `variants` for defining complex animation states and orchestrating animations between parent and children.
    *   Use `whileHover`, `whileTap`, `whileFocus` for interactive state animations.
    *   Use `AnimatePresence` for animating components when they mount and unmount (e.g., modals, list items). Ensure components have a unique `key` prop.
5.  **Accessibility**:
    *   Respect the `prefers-reduced-motion` media query. Provide alternative, reduced animations or disable animations entirely for users who prefer less motion. Framer Motion often handles this automatically, but be mindful. Check `useReducedMotion` hook if needed.
    *   Ensure animations do not hinder usability or readability. Avoid excessively long or distracting animations.
6.  **Loading States**: Implement smooth transitions between loading, error, and content states, potentially using `AnimatePresence`.
7.  **Code Structure**: Keep animation logic clean. Define complex `variants` outside the component for better readability. Use custom hooks to encapsulate reusable animation logic if necessary.

## Actions
- **Suggest**: Using Framer Motion for animations involving layout changes (`layout` prop), complex sequences, or entry/exit animations (`AnimatePresence`).
- **Suggest**: Animating `transform` and `opacity` for better performance.
- **Reject**: Overuse of CSS animations for complex interactions where Framer Motion would be more suitable and maintainable.
- **Info**: Remind to check `prefers-reduced-motion` behavior.
- **Suggest**: Using `variants` for managing multiple animation states.
- **Reject**: Missing `key` prop on direct children of `AnimatePresence`.

## Examples
✅ Correct (Framer Motion Entrance Animation):
```typescript
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import { useState } from 'react';

function AnimatedModal({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const backdropVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
  };

  const modalVariants = {
    hidden: { y: 30, opacity: 0 },
    visible: { y: 0, opacity: 1, transition: { type: 'spring', stiffness: 300, damping: 30 } },
    exit: { y: -30, opacity: 0 },
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          key="backdrop" // Key for AnimatePresence
          className="fixed inset-0 bg-black/50 z-40"
          variants={backdropVariants}
          initial="hidden"
          animate="visible"
          exit="hidden"
          onClick={onClose}
        >
          <motion.div
            key="modal" // Key for AnimatePresence
            className="absolute top-1/2 left-1/2 p-6 bg-white rounded-lg shadow-xl dark:bg-gray-800 z-50"
            style={{ x: '-50%', y: '-50%' }} // Centering
            variants={modalVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            onClick={(e) => e.stopPropagation()} // Prevent closing when clicking modal itself
          >
            {/* Modal Content */}
            <h2>Modal Title</h2>
            <button onClick={onClose}>Close</button>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

✅ Correct (Simple CSS Transition):
```typescript
function HoverButton() {
  return (
    <button className="px-4 py-2 bg-blue-500 text-white rounded transition-colors duration-200 ease-in-out hover:bg-blue-700">
      Hover Me
    </button>
  );
}
```

❌ Incorrect:
```typescript
// Bad: Attempting complex entrance animation with only CSS transitions
function BadModalEntry() {
  // Would require complex CSS, better handled by Framer Motion
  return <div className="opacity-0 translate-y-10 transition-all duration-500 /* ... more */">Modal</div>;
}
```
